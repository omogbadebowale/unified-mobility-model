import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit, differential_evolution

# ---------------- Data: BLUE series from Fig. 8 ----------------
# Fe2VAl0.9Si0.1, x = 0 (n-type), axes assumed T:0–500 K, mu:0–60 cm^2/V·s
T_all  = np.array([44.6, 58.4, 73.9, 91.3, 108.0, 124.5, 141.8, 157.7, 175.1,
                   191.6, 208.2, 225.6, 241.2, 258.8, 275.2, 291.8, 309.3,
                   325.1, 342.4, 359.8, 375.7, 393.0, 408.7, 426.1, 443.5,
                   459.3, 476.5], dtype=float)
mu_all = np.array([55.6, 53.7, 52.3, 49.7, 43.7, 38.6, 34.1, 30.8, 26.5, 24.1,
                   22.0, 21.1, 18.0, 17.5, 15.6, 14.0, 11.9, 10.8,  9.5,  8.9,
                    7.8,  7.2,  6.6,  5.8,  4.9,  4.2,  4.1], dtype=float)

# Fit only above ~100 K (as discussed in the paper)
mask = T_all >= 100.0
T, mu = T_all[mask], mu_all[mask]

# ---------------- Unified mobility model ----------------
k_B = 8.617333262e-5  # eV/K
T0  = 300.0           # K
W_GB = 20.0           # nm (fixed; only l300/W_GB is identifiable)

def l_of_T(T, l300, p):
    return l300 * (T / T0)**(-p)

def mu_model(T, mu_w, Phi_GB, l300, p, w_GB=W_GB):
    lT = l_of_T(T, l300, p)
    return mu_w * np.exp(-Phi_GB / (k_B * T)) * (lT / (lT + w_GB))

# ---------------- Fit (global init -> local refine) ----------------
# n-type: monotonic μ(T); push barrier near zero
lb = np.array([  1.0, 0.0,   1.0, 0.8])   # mu_w, Phi_GB(eV), l300(nm), p
ub = np.array([300.0, 0.02, 500.0, 2.2])

def sse(p):
    mu_w, Phi, l300, pwr = p
    return np.sum((mu - mu_model(T, mu_w, Phi, l300, pwr))**2)

# Global initialization (reproducible)
de = differential_evolution(sse, bounds=list(zip(lb, ub)), seed=1, polish=True, tol=1e-6, maxiter=400)
p0 = de.x

# Local bounded least-squares (TRF under the hood with bounds)
popt, pcov = curve_fit(lambda TT, mu_w, Phi, l300, pwr: mu_model(TT, mu_w, Phi, l300, pwr),
                       T, mu, p0=p0, bounds=(lb, ub), maxfev=30000)
perr = np.sqrt(np.diag(pcov)) if np.all(np.isfinite(pcov)) else np.full_like(popt, np.nan)

# Goodness of fit
mu_hat = mu_model(T, *popt)
ss_res = np.sum((mu - mu_hat)**2)
ss_tot = np.sum((mu - mu.mean())**2)
R2 = 1 - ss_res/ss_tot if ss_tot > 0 else np.nan

# ---------------- Plot (SnSe style) ----------------
Tfine = np.linspace(T.min(), T.max(), 500)
mu_fit = mu_model(Tfine, *popt)

plt.figure(figsize=(6,4.5))
plt.plot(Tfine, mu_fit, '-', color='red', lw=2, label='Model')
plt.plot(T, mu, 'o', ms=6, mec='blue', mfc='white', mew=1.5, color='blue', label=r'Fe$_2$VAl$_{0.9}$Si$_{0.1}$, $x=0$')
plt.xlabel('T (K)')
plt.ylabel(r'$\mu_{\mathrm{eff}}$ (cm$^2$/V·s)')
plt.grid(True, alpha=0.3)
plt.legend(frameon=False)
plt.tight_layout()
plt.show()

# ---------------- Print parameters ----------------
print("Fitted parameters (±1σ), w_GB fixed at {:.1f} nm".format(W_GB))
print("  mu_w   = {:.2f} ± {:.2f} cm^2/V·s".format(popt[0], perr[0]))
print("  Phi_GB = {:.4e} ± {:.4e} eV".format(popt[1], perr[1]))
print("  l_300  = {:.2f} ± {:.2f} nm".format(popt[2], perr[2]))
print("  p      = {:.3f} ± {:.3f}".format(popt[3], perr[3]))
print("  R^2    = {:.4f}".format(R2))
